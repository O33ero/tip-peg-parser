## Построение синтаксического дерева для языка TIP

##### Requirements:
- Java 21

##### Компиляция проекта и запуск
```
mvn compile package
```

```
java -jar tip-peg-parser-1.0.0-jar-with-dependencies.jar code.txt
```

В качества параметра запуска передается путь до файла с кодом.


##### Описание

Лексикографический парсер и построение дерева работает для языка TIP со следующей грамматикой:

```
Int -> 0 | 1 | -1 | 2 | -2 | ... 
Id -> x | y | z | ... 
Exp -> Int | Id | Exp + Exp | Exp - Exp | Exp * Exp | Exp / Exp | Exp > Exp | Exp == Exp | ( Exp ) | input
Stm → Id = Exp ; | output Exp ; | Stm Stm | if ( Exp ) { Stm } else { Stm } | while ( Exp ) { Stm }
```

Промежуточным результатом является объект класса `RootStatement`, который содержит в себе всю древовидную структуру исходных данных. Вокруг этого объекта можно менять репрезнентацию результирующего AST-дерева. 

<img src='./img/img0.png' wigth='800' height='700'>


##### Пример

---

_Input:_
```
x = 10;           
if (x > input) { 
    while (input > 10) {
        output x;
    }
} else {
    while (input > 10) {
        output 0;
    }
} 
```

_Output:_
```
root ↓
    x = 10
    if x > input is true ↓
        while input > 10 is true ↺
            output: x
    else ↓
        while input > 10 is true ↺
            output: 0
```
---

_Input:_
```
x = 10; if (x > 9) { output x; } else { output 0; }
```

_Output:_
```
root ↓
    x = 10
    if x > 9 is true ↓
        output: x
    else ↓
        output: 0
```
---
Другие примеры кода находятся в тестах проекта.

--- 
## Реализация того, что тут происходит
### Идея

Нужно исходный код некоторой программы из текстового варианта разобрать в дерево, 
где каждый элемент (if-else, циклы, переменные и все остальное) будут узлами, 
которые будут привязаны к одному родителю.

Если взять простейшое выражение `if (x > 5)`, то его можно представить в виде дерева
с корнем `if` и тремя "детьми" - `x`, `5`, `>`.

### Условия задачи

Разобрать надо язык `tip`, который представлен грамматикой:
```
Int -> 0 | 1 | -1 | 2 | -2 | ... 
Id -> x | y | z | ... 
Exp -> Int | Id | Exp + Exp | Exp - Exp | Exp * Exp | Exp / Exp | Exp > Exp | Exp == Exp | ( Exp ) | input
Stm → Id = Exp ; | output Exp ; | Stm Stm | if ( Exp ) { Stm } else { Stm } | while ( Exp ) { Stm }
```
На человеческом языке это значит, что 
- есть бесконечное множество `Значений`(`Int`), которое представляет собой множество целых чисел;
- есть бесконечно множество `Переменных` (`Id`), которое представляет собой имена некоторых абстрактных `Значений`
- есть множество `Выражений` (`Exp`), которое описывает собой все возможные выражения, которые могут использоватся в языке.
Выражения могут быть просто `Переменной` или просто `Значением`, а также выражение это сумма(и любая другая операция) других выражений. 
Также есть "волшебное" выражение `input`, которое не является переменной и значением, но является выражением (выжно для парсера)
- есть множество `Операторов` (`Stm`), которые описывают манипуляции над выражениями (проще говоря, if-else, циклы, присвоение и т.д)

Надо написать программу, которая это все грамматно разбивает в дерево, с соответсвием выше описанным правилам.

### Реализация

Входные данные: текст (неизвестно какой, неизвестного формата, размера и т.д)
Выходные данные: ast-дерево для языка tip

Разобьем алгоритм на верхнеуровневые шаги:
1. Парсинг входящих значений;
2. Превращение символов в токены(_токены_ - атомарный объект, описывающий фрагмент исходного кода);
3. Превращение токенов в дерево;
4. Визуализация дерева.

Эти шаги будут в любой реализации построения AST-дерева независимо от сложности парсера. Конкретные решения далее.

#### Техническая реализация

Опишем техническую реализацию с подробным описанием шагов:

1. Парсинг входящих значений
   1. Разбиваем строки на слова - с символами сложно работать, а слова еще куда не шло
   2. Фильтруем слова - выкидываем мусорные слова (пустые), потому что они нам не нужны
2. Превращаем символы в токены
   1. Для каждого множества (`Выражений`, `Операторов`) составляем регулярки того, как она должны выглядеть. 
   Поскольку мы все разбили на слов, то мы можем контролировать каким образом будут выглядить те или иные операторы.
   2. Для каждого множества (`Значений`, `Переменных`) составляем регулярки, они пригодятся позже
   3. Строим токены с помощью склеивания с последующим (используем буффер) и проверкой "получился ли токен?", путем проверки с каждой нашей подготовленной регуляркой.
   Если токен не получился, то приклеиваем следующий. И так до конца.
   4. Если токен получился, то удаляем его из буффера путем заменой по регулярке токена, который мы только что нашли.
   5. Если после слеивания с последним словом не получился токен, то выкидываем ошибку парсинга.
   6. Для каждой составленого на шаге 2.3 токена еще проверяем по регулярке его составляющие. То есть для токена `if` делаем еще проверку его условий на соответсиве того что там (в скобках условий) находится `Exp`. 
   Для каждого такого `Exp` делаем еще раз проверку, что в нем тоже лежит сумма(или любой другой оператор) `Exp` или примитивный тип (`Переменная` или `Значение`). 
   Крутим по рекурсии `Exp` пока не дойдем до примитивных `Id` или `Int`.
   7. Для дальнейших преобразований сделал множество `Выражений` разных типов у которых отсутствует параменная для операции. Например, можно задать
   множество операторов как экземпляры `Exp(a, b, op)`, где `a`, `b` - некоторые переменные, а `op` - операция между ними. Но мы поступим иначе,
   создадим разные типы классов: создадим классы `PlusExp(a, b)`, `MinusExp(a, b)`, для которых будет отсутствовать оператор как отдельное поле, поскольку оно
   будет вшито в логику класса.
   8. Для дальнейших преобразований ввел новый тип выражений - `Конец оператора` (для простоты назовем его `End`), который описывает закрывающую скобку. Он понадоится дальше.
   9. Складываем все найденные токены в массив с сохранением порядка (порядок как будто не существует условных операторов).
3. Превращаем токены в дерево
   1. Прокрутим входной массив токенов и соберем их в дерево по следующей логике:
      1. Создадим корень. Так его и назовем - `Root`.
      2. Запомним текущий корень. По умолчанию, `Root`.
      3. Запускаем цикл прокрутки токенов:
      4. Возьмем следующий токен
      5. Назначим для него родителя текущем корнем
      6. Если это ветвление (`if`, `else`, `while`), то
         1. Запомним его как текущий корень
      7. Если это `Конец оператора` (`End`), то
         1. Вернем текущий корень, который был до текущего (используем для этих фокусов запомиание в стек)
      8. Возвращаемся на шаг 4, пока не закончится входящий массив
   2. После прокручивания получаем дерево с корнем `Root` и всей остальной программой в качестве ветвления
4. Визуализация дерева
   1. Берем дерево полученное из предыдущего шага
   2. Добавляем корень в стек
   3. Задаем отступ по умолчанию
   4. Прокручиваем стек:
      1. Берем элемент из стека
      2. Печатаем элемент с отступом
      3. Если это ветвление (`if`, `else`, `while`), то
         1. Делаем оступ для следующих шагов +1
         2. Добавляем всех его "детей" в стек в обратном порядке
         3. Возвращаемся на шаг 1, пока не закончится стек
   5. После прокрутки всего дерева выведется визуализация, соотвественно, этого дерева
